#include <iostream>
#include <fstream>
#include <vector>
#include <ctime>
#include <stdlib.h>
#include <string.h>

#include <cuda_runtime.h>
#include "hashiru_cuda.cuh"

/*** Useful GPU Macros ***/
#define gpuErrChk(ans) { gpuAssert((ans), __FILE__, __LINE__); }
inline void gpuAssert(cudaError_t code,
                      const char *file,
                      int line,
                      bool abort=true) {
  if (code != cudaSuccess) {
    fprintf(stderr,"GPUassert: %s %s %d\n",
            cudaGetErrorString(code), file, line);
    exit(code);
  }
}

using namespace std;

/*
 * A simple toy hash function I wrote because the
 * actual hash function was not going to be finished
 * in time.  It sums up all the chars in a string,
 * mods 26, adds to 'a' to get a lowercase alphabetic
 * char, and then pads 31 'F' characters.
 */
string cpu_hash(string in)
{
    string result;
    char c = 0;
    for(int i = 0; i < in.length(); i++)
    {
        c += in[i];
    }
    c = 97 + c % 26;
    result.push_back(c);
    for(int i = 0; i < 31; i++)
    {
        result.push_back('F');
    }
    return result;
}

int main(int argc, char **argv)
{
    /*** Communal Setup ***/
    // Check the arguments
    if(argc != 5)
    {
        cerr << "usage: hashiru path_to_dict hash_to_crack threads_per_block num_blocks" << endl;
        return EXIT_FAILURE;
    }
    char *dict_path = argv[1];
    char *to_crack = argv[2];

    // Reject hashes of inappropriate length
    if(strlen(to_crack) != 32)
    {
        cerr << "fatal: target hashes must be 32 characters" << endl;
        return EXIT_FAILURE;
    }

    ifstream dict_file;
    vector<string> dict;
    string temp;

    // Open the given dictionary file
    dict_file.open(dict_path);
    if(!dict_file)
    {
        // If the file doesn't exist, complain and quit.
        cerr << "fatal: can't open dictionary file" << endl;
        return EXIT_FAILURE;
    }

    int max_length = 0;
    while(!dict_file.eof())
    {
        // For every line in the file, treat it as a new string
        // in the dictionary.
        dict_file >> temp;
        dict.push_back(temp);
        // Keep track of the maximum length candidate.
        if(temp.length() > max_length)
        {
            max_length = temp.length();
        }
    }

    /*** CPU Implementation ***/
    clock_t start_cpu;
    double duration;
    string cur, cur_hash;
    int found = 0;
    // Start timer
    start_cpu = clock();
    for(vector<string>::iterator it = dict.begin(); it != dict.end(); ++it)
    {
        // Get current string and compute its hash.
        cur = *it;
        cur_hash = cpu_hash(cur);
        int match = 1;
        // Janky CPU strcmp ensuring we cover all 32 characters
        // (In case a \0 shows up as a result of the hash, which
        // it shouldn't, but it's too late to change this).
        for(int i = 0; i < 32; i++)
        {
            if(cur_hash[i] != to_crack[i]) match = 0;
        }
        // If it's a match, print the analysis.
        if(match)
        {
            duration = (clock() - start_cpu) / (double) CLOCKS_PER_SEC;
            cout << "PASSWORD FOUND" << endl;
            cout << "Hash: " << to_crack << " is generated by: " << cur << endl;
            cout << "CPU time taken: " << duration << " seconds" << endl;
            found = 1;
            break;
        }
    }
    // If nothing matches, complain that the attack failed.
    if(!found)
    {
        duration = (clock() - start_cpu) / (double) CLOCKS_PER_SEC;
        cout << "Did not find password matching hash in dictionary" << endl;
        cout << "CPU time taken: " << duration << " seconds" << endl;
    }

    /*** GPU Implementation ***/
    const int threads_per_block = atoi(argv[3]);
    const int num_blocks = atoi(argv[4]);
    float time_taken;
    int correct_idx = -1;
    cudaEvent_t start;
    cudaEvent_t stop;

#define START_TIMER() {                         \
      gpuErrChk(cudaEventCreate(&start));       \
      gpuErrChk(cudaEventCreate(&stop));        \
      gpuErrChk(cudaEventRecord(start));        \
    }

#define STOP_RECORD_TIMER(name) {                           \
      gpuErrChk(cudaEventRecord(stop));                     \
      gpuErrChk(cudaEventSynchronize(stop));                \
      gpuErrChk(cudaEventElapsedTime(&name, start, stop));  \
      gpuErrChk(cudaEventDestroy(start));                   \
      gpuErrChk(cudaEventDestroy(stop));                    \
    }



    // Allocate memory on the GPU
    // Specifically, we need the dictionary, the correct index, and the target
    // hash.
    char *dev_dict;
    int *dev_correct_idx;
    char *dev_target;
    // Assume every string in the dictionary is the maximum length, add 1 byte
    // for the null terminator.  Yes, this is a waste of memory, but it's
    // a quick and sloppy fix.
    gpuErrChk(cudaMalloc((void **) &dev_dict, dict.size() * (max_length + 1) * sizeof(char)));
    gpuErrChk(cudaMemset(dev_dict, 0, dict.size() * (max_length + 1) * sizeof(char)));
    // The correct index is just a single integer.
    gpuErrChk(cudaMalloc((void **) &dev_correct_idx, sizeof(int)));
    gpuErrChk(cudaMemset(dev_correct_idx, -1, sizeof(int)));
    // The target hash has to be 32 characters.
    gpuErrChk(cudaMalloc((void **) &dev_target, 32 * sizeof(char)));
    gpuErrChk(cudaMemcpy(dev_target, to_crack, 32 * sizeof(char), cudaMemcpyHostToDevice));
    // Copy over all the strings in the dict to the GPU memory
    // Yes, we are wasting memory by padding out all strings to
    // the max length, but C strings are unpleasant and this is a
    // fast and dirty fix.
    for(int i = 0; i < dict.size(); i++)
    {
        temp = dict.at(i);
        gpuErrChk(cudaMemcpy(dev_dict + ((max_length + 1) * i), temp.c_str(), temp.length() * sizeof(char), cudaMemcpyHostToDevice));
    }

    // Start the timer, call the kernel, stop the timer.
    START_TIMER();
    cudaCallCrackHashKernel(num_blocks, threads_per_block, dev_dict, max_length, dict.size(), dev_target, dev_correct_idx);
    STOP_RECORD_TIMER(time_taken);

    // Copy over the correct index.
    gpuErrChk(cudaMemcpy(&correct_idx, dev_correct_idx, sizeof(int), cudaMemcpyDeviceToHost));
    // If it's still -1, the attack failed.  Complain.
    if(correct_idx == -1)
    {
        cout << "Did not find password matching hash in dictionary" << endl;
        cout << "GPU time taken: " << time_taken / 1000.0 << " seconds" << endl;
    }
    // Otherwise, print the correct answer.
    else
    {
        cout << "PASSWORD FOUND" << endl;
        cout << "Hash: " << to_crack << " is generated by: " << dict.at(correct_idx) << endl;
        cout << "GPU time taken: " << time_taken / 1000.0 << " seconds" << endl;
    }
    cout << "GPU speedup factor is: " << duration / (time_taken / 1000.0) << endl;

    /*** Cleanup ***/
    dict_file.close();
    cudaFree(dev_dict);
    cudaFree(dev_correct_idx);
    cudaFree(dev_target);
    return 0;
}
